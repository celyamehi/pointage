from datetime import datetime, date, time
from typing import Dict, Any, List, Optional
import uuid
from zoneinfo import ZoneInfo

from app.db import get_db
from app.qrcode.utils import validate_qrcode

# Fuseau horaire pour la France
TIMEZONE = ZoneInfo("Europe/Paris")


async def determine_session() -> str:
    """
    DÃ©termine la session (matin ou aprÃ¨s-midi) en fonction de l'heure actuelle
    """
    now_paris = datetime.now(TIMEZONE)
    current_hour = now_paris.hour
    print(f"ğŸ•’ Heure actuelle (Paris): {now_paris.strftime('%H:%M:%S')} - Session: {'matin' if current_hour < 12 else 'aprÃ¨s-midi'}")
    
    if current_hour < 12:
        return "matin"
    else:
        return "apres-midi"


async def create_pointage(agent_id: str, qrcode: str) -> Dict[str, Any]:
    """
    CrÃ©e un nouveau pointage pour un agent
    """
    db = await get_db()
    
    # VÃ©rifier si le QR code est valide
    is_valid = await validate_qrcode(qrcode)
    if not is_valid:
        raise ValueError("QR code invalide ou expirÃ©")
    
    # DÃ©terminer la session (matin ou aprÃ¨s-midi)
    session = await determine_session()
    
    # VÃ©rifier si l'agent a dÃ©jÃ  pointÃ© pour cette session aujourd'hui
    try:
        # Utiliser la date de Paris
        now_paris = datetime.now(TIMEZONE)
        today = now_paris.date().isoformat()
        print(f"VÃ©rification des pointages existants pour l'agent {agent_id} Ã  la date {today} et la session {session}")
        existing_pointage = db.table("pointages").select("*").eq("agent_id", agent_id).eq("date_pointage", today).eq("session", session).execute()
        
        if existing_pointage.data and len(existing_pointage.data) > 0:
            print(f"Pointage existant trouvÃ© pour l'agent {agent_id}")
            raise ValueError(f"Vous avez dÃ©jÃ  pointÃ© pour la session {session} aujourd'hui")
    except Exception as e:
        print(f"Erreur lors de la vÃ©rification des pointages existants: {str(e)}")
        # Continuer mÃªme en cas d'erreur
    
    # CrÃ©er le pointage avec l'heure de Paris
    now_paris = datetime.now(TIMEZONE)
    new_pointage = {
        "id": str(uuid.uuid4()),
        "agent_id": agent_id,
        "date_pointage": today,
        "heure_pointage": now_paris.strftime("%H:%M:%S"),
        "session": session
    }
    print(f"ğŸ“Œ Pointage crÃ©Ã© - Date: {today}, Heure: {now_paris.strftime('%H:%M:%S')}, Session: {session}")
    
    try:
        print(f"Insertion d'un nouveau pointage: {new_pointage}")
        result = db.table("pointages").insert(new_pointage).execute()
        print(f"RÃ©sultat de l'insertion: {result}")
    except Exception as e:
        print(f"Erreur lors de l'insertion du pointage: {str(e)}")
        raise Exception(f"Erreur lors de l'enregistrement du pointage: {str(e)}")
    
    if not result.data or len(result.data) == 0:
        raise Exception("Erreur lors de l'enregistrement du pointage")
    
    pointage_db = result.data[0]
    
    return {
        "id": pointage_db["id"],
        "agent_id": pointage_db["agent_id"],
        "date_pointage": pointage_db["date_pointage"],
        "heure_pointage": pointage_db["heure_pointage"],
        "session": pointage_db["session"],
        "created_at": pointage_db["created_at"]
    }


async def get_pointages_by_agent(agent_id: str, start_date: Optional[date] = None, end_date: Optional[date] = None) -> List[Dict[str, Any]]:
    """
    RÃ©cupÃ¨re les pointages d'un agent sur une pÃ©riode donnÃ©e
    """
    db = await get_db()
    
    try:
        print(f"RÃ©cupÃ©ration des pointages pour l'agent {agent_id} du {start_date} au {end_date}")
        query = db.table("pointages").select("*").eq("agent_id", agent_id)
        
        if start_date:
            query = query.gte("date_pointage", start_date.isoformat())
        
        if end_date:
            query = query.lte("date_pointage", end_date.isoformat())
        
        result = query.order("date_pointage", desc=False).execute()
        print(f"Nombre de pointages rÃ©cupÃ©rÃ©s: {len(result.data) if result.data else 0}")
    except Exception as e:
        print(f"Erreur lors de la rÃ©cupÃ©ration des pointages: {str(e)}")
        return []
    
    return result.data if result.data else []


async def get_pointages_by_date(date_pointage: date) -> List[Dict[str, Any]]:
    """
    RÃ©cupÃ¨re tous les pointages pour une date donnÃ©e
    """
    db = await get_db()
    
    try:
        print(f"RÃ©cupÃ©ration des pointages pour la date {date_pointage}")
        result = db.table("pointages").select("*").eq("date_pointage", date_pointage.isoformat()).execute()
        print(f"Nombre de pointages rÃ©cupÃ©rÃ©s: {len(result.data) if result.data else 0}")
    except Exception as e:
        print(f"Erreur lors de la rÃ©cupÃ©ration des pointages par date: {str(e)}")
        return []
    
    return result.data if result.data else []


async def format_pointages_by_date(agent_id: str, start_date: Optional[date] = None, end_date: Optional[date] = None) -> List[Dict[str, Any]]:
    """
    Formate les pointages d'un agent par jour avec matin et aprÃ¨s-midi
    """
    try:
        print(f"Formatage des pointages pour l'agent {agent_id} du {start_date} au {end_date}")
        pointages = await get_pointages_by_agent(agent_id, start_date, end_date)
    except Exception as e:
        print(f"Erreur lors du formatage des pointages: {str(e)}")
        return []
    
    # Organiser les pointages par date
    pointages_by_date = {}
    
    for pointage in pointages:
        date_str = pointage["date_pointage"]
        
        if date_str not in pointages_by_date:
            pointages_by_date[date_str] = {
                "date": date_str,
                "matin": None,
                "apres_midi": None
            }
        
        if pointage["session"] == "matin":
            pointages_by_date[date_str]["matin"] = pointage["heure_pointage"]
        else:
            pointages_by_date[date_str]["apres_midi"] = pointage["heure_pointage"]
    
    # Convertir en liste
    return list(pointages_by_date.values())
